---
title: "AI 기반 에러 모니터링 자동화 파이프라인 구축기"
description: "Sentry 에러를 Claude가 자동 분석하고 Jira 티켓과 Slack 알림까지 보내주는 서버리스 파이프라인 구축기"
date: "2026-01-28"
category: "DX"
tags: ["AI", "Sentry", "자동화", "DX"]
---

## 들어가며

프로덕션 에러가 발생하면 어떻게 되는가. Sentry가 감지하고, 이메일이 온다. 하지만 스프린트 중간에 Sentry 이메일을 실시간으로 확인하는 사람은 많지 않다. 결국 몇 시간 뒤에야 인지하게 되고, 운이 나쁘면 PM이 먼저 물어본다. "이거 에러 나고 있는 거 알아요?"

에러를 인지한 뒤에도 세레모니가 남아있다. Sentry 열어서 스택 트레이스 읽고, 원인 파악하고, Jira에 티켓 만들고, 설명 쓰고, 맞는 Epic에 연결하고, Slack에 팀한테 공유하고. 한 건당 10-15분은 잡아먹는다. 도구만 3-4개를 오간다. 반복적이고, 지루하고, 그래서 바쁠 때는 대충 하게 된다.

문제는 에러 인지가 느린 것도, 티켓 생성이 귀찮은 것도 아니다. **에러 대응의 전체 흐름이 수동**이라는 게 문제다.

[AI 코드 리뷰 파이프라인](../posts/ai-code-review-pipeline)에 이어서, 이번에는 에러 모니터링 쪽을 자동화해보기로 했다. 이번에도 POC다. 개인 Anthropic API 계정으로, 월 $10 정도 예산으로 시작했다. 성과가 나오면 팀에 어필하려는 목적이었다.

---

## 전체 구조

```
1. 프로덕션 에러 발생
   ↓
2. Sentry 감지 & 필터링 (Priority, Level)
   ↓
3. Webhook → API Gateway → AWS Lambda
   ↓
4. Claude Opus 에러 분석
   ↓
5. Jira Bug 티켓 자동 생성 (Epic 하위)
   ↓
6. Slack 알림 전송
```

- **Sentry** — 에러 수집, Webhook 트리거
- **AWS Lambda** — 서버리스 처리 엔진
- **Claude Opus 4.5** — AI 에러 분석
- **Jira REST API** — 티켓 자동 생성
- **Slack API** — 알림 전송

---

## 필터링과 중복 방지

모든 에러에 대해 AI 분석 + 티켓 생성을 돌리면 두 가지 문제가 생긴다. 노이즈가 넘치고, API 비용이 불필요하게 늘어난다.

필터링은 두 레이어로 나눴다.

### Sentry Alert Rule

Sentry에서는 Priority와 Level만 필터링한다. 조건에 맞으면 무조건 Webhook을 트리거한다.

- **Priority**: High, Medium만. Low는 제외.
- **Level**: Error, Fatal만. Warning, Info는 제외.

```
WHEN  새로운 이슈가 생성되면
IF    priority = high 또는 medium
AND   level >= error
THEN  Webhook POST 호출
```

### Lambda 중복 검사

Sentry가 같은 이슈에 대해 여러 번 Webhook을 보낼 수 있다. 이걸 Sentry 쪽에서 rate limit으로 막을 수도 있지만, 그보다는 Lambda에서 **이미 해당 이슈의 Jira 티켓이 존재하는지** 확인하는 방식을 택했다.

기존에 같은 이슈의 티켓이 있으면 Claude 분석, Jira 티켓 생성, Slack 알림 전부 스킵한다. 이렇게 하면 두 가지를 동시에 잡을 수 있다.

- **API 비용 절약**: 이미 티켓이 있는 이슈에 대해 Claude API를 호출하지 않는다.
- **중복 티켓 방지**: 같은 에러에 대한 Jira 티켓이 여러 개 생기지 않는다.

AI 코드 리뷰 때도 MR에 이미 리뷰가 있으면 스킵하는 같은 패턴을 썼다. 멱등성을 보장하면서 API 호출을 아끼는 방법이다.

---

## AI 에러 분석

파이프라인의 핵심이다. 단순히 Sentry 에러를 Jira로 포워딩하는 거라면 AI가 필요 없다. Claude가 에러를 분석해서 **원인 추정과 해결 방법까지 제안**하는 게 이 파이프라인의 차별점이다.

### 프롬프트

```typescript
const prompt = `당신은 10년차 시니어 프론트엔드 개발자입니다. 다음 Sentry 에러를 분석해주세요.

## 에러 정보
- 제목: ${issue.title}
- 위치: ${issue.culprit}
- 타입: ${issue.metadata?.type || "Unknown"}
- 값: ${issue.metadata?.value || "Unknown"}
- 프로젝트: ${issue.project?.slug || "Unknown"}

## 분석 요청
다음 형식의 JSON으로만 응답해주세요:

{
  "cause": "에러 발생 원인을 1-2문장으로 설명",
  "solution": "구체적인 해결 방법을 1-2문장으로 설명",
  "severity": "critical | high | medium | low",
  "category": "frontend | backend | api | auth | infra | unknown",
  "codeExample": "수정이 필요한 코드 예시 (없으면 null)"
}`;
```

JSON 형식을 강제해서 파싱 실패 없이 안정적으로 후속 처리(Jira 티켓 생성, Slack 메시지 구성)를 할 수 있게 했다. 이 패턴은 AI 코드 리뷰 때도 같은 방식으로 검증했던 거라 안심하고 적용했다.

### 분석 결과 예시

실제로 `Cannot read property 'id' of undefined` 에러가 발생했을 때 Claude가 돌려준 분석이다.

```json
{
  "cause": "user 객체가 null인 상태에서 id 프로퍼티에 접근하고 있습니다. API 응답이 비어있거나 인증 상태가 유효하지 않을 때 발생합니다.",
  "solution": "Optional chaining(user?.id)을 적용하고, user 객체가 없는 경우에 대한 폴백 처리를 추가해야 합니다.",
  "severity": "high",
  "category": "frontend",
  "codeExample": "const userId = user?.id ?? null;"
}
```

이게 항상 정확한 건 아니다. 하지만 "에러가 뭔지 전혀 모르는 상태"에서 시작하는 것과, "대략적인 원인과 방향이 이미 정리된 상태"에서 시작하는 건 체감이 꽤 다르다.

---

## Jira 티켓 자동 생성

회사에서 Sentry 프로젝트가 여러 개 있고, 각각 다른 Jira 프로젝트에 매핑된다. 에러가 어디서 발생했느냐에 따라 티켓이 올바른 프로젝트의 올바른 Epic 하위에 생성되어야 한다.

### 프로젝트 라우팅

```typescript
const PROJECT_CONFIG = {
  wello: {
    jiraProjectKey: "WEL",
    epicKey: "WEL-3527",
  },
  "admin-donation": {
    jiraProjectKey: "WEL",
    epicKey: "WEL-3527",
  },
  "wello-biz": {
    jiraProjectKey: "WL",
    epicKey: "WL-2153",
  },
};
```

Sentry의 `project.slug`를 키로 Jira 프로젝트와 Epic을 결정한다. 새 프로젝트가 추가되면 여기에 한 줄 추가하면 끝이다.

### 티켓 내용

Jira에 생성되는 Bug 티켓에는 다음이 포함된다.

- **제목**: `[Sentry] {에러 제목}`
- **AI 분석 결과**: 원인, 해결 방법, 심각도, 카테고리를 테이블로 정리
- **코드 예시**: Claude가 제안한 수정 코드 (있을 경우)
- **링크**: Sentry 이슈 바로가기, Session Replay 바로가기
- **라벨**: `sentry-auto`, 심각도, 카테고리

티켓이 Epic 하위 Bug 이슈로 생성되기 때문에, 에러 관련 이슈들이 자동으로 그룹핑된다. 나중에 "이번 스프린트에 Sentry에서 잡힌 에러가 몇 건이지?" 추적하기도 편하다.

---

## Slack 알림

Slack은 알림 레이어다. 개발자가 가장 먼저 보는 곳이 Slack이니까, 여기서 핵심 정보만 빠르게 전달하는 게 목적이다.

```
🟠 새로운 에러 발생
[Wello] Cannot read property 'id' of undefined
📍 위치: src/components/UserProfile.tsx in getUserData

🔍 원인: user 객체가 null인 상태에서 접근
💡 해결: Optional chaining 적용

심각도: HIGH | 분류: frontend

[📋 Jira 티켓] [🔍 Sentry] [🎬 Replay]
```

심각도에 따라 이모지 색상이 바뀐다. Critical은 빨간색, High는 주황색, Medium은 노란색. Slack 메시지 하나로 상황 파악하고, 버튼 눌러서 Jira 티켓이나 Sentry로 바로 이동할 수 있다.

핵심은, 개발자가 이 Slack 메시지를 봤을 때 **Jira 티켓이 이미 존재한다**는 것이다. "티켓 만들어야지" 가 아니라 "바로 확인하자"가 된다.

---

## 비용

POC라서 비용을 최소화하는 게 중요했다. 개인 Anthropic API 계정으로 진행했고, 월 $10 Usage Limit을 설정해뒀다.

- **AWS Lambda** — 월 120-180건 호출 수준이라 사실상 무시할 수 있는 비용
- **API Gateway** — Lambda와 마찬가지로 미미한 수준
- **Claude API** — ~$4-6 (월 120-180건 기준)
- **Sentry, Jira, Slack** — 기존 사용 중, 추가 비용 없음
- **합계 — ~$6/월**

Claude API 비용 상세를 좀 더 풀어보면 이렇다.

- **Input** (에러 정보): 180건 × 3,000토큰 = 540,000토큰 → $2.70
- **Output** (분석 결과): 180건 × 800토큰 = 144,000토큰 → $3.60
- **합계: ~$6.30/월**

필터링으로 High + Medium Priority만 처리하면 ~120건, 약 $4.20으로 줄어든다. 개발자 한 명이 수동으로 에러 대응하는 시간을 생각하면, 월 $6은 충분히 합리적인 비용이다.

---

## 결과

### 좋았던 것

- **에러 인지 시간 단축**: 에러 발생 후 Slack 알림까지 1-2분. "몇 시간 뒤에야 알았다"가 사라졌다. 더 이상 PM한테 먼저 연락 받을 일이 없다.
- **티켓 생성 자동화**: 수동으로 10-15분 걸리던 게 자동 30초. Sentry 열고, 분석하고, Jira에 복붙하고, Epic 연결하는 반복 작업이 완전히 없어졌다.
- **일관된 분석 품질**: 사람은 바쁘면 "TypeError 발생" 한 줄짜리 티켓을 만든다. AI는 매번 같은 형식으로 원인, 해결 방법, 심각도, 카테고리를 정리해준다. 티켓 품질의 편차가 사라졌다.
- **컨텍스트 스위칭 감소**: Sentry → Jira → Slack을 오가며 에러를 "처리"하던 과정이, Slack 메시지 하나 확인하고 Jira 티켓에서 바로 작업을 시작하는 흐름으로 바뀌었다.

### 한계

- **비즈니스 맥락은 모른다.** Claude는 기술적으로 "null 참조 에러"라고 분석할 수 있지만, "이 에러가 결제 플로우를 막고 있어서 핫픽스가 필요하다"는 사람이 판단해야 한다.
- **복잡한 에러는 분석이 빗나간다.** 여러 서비스가 얽힌 에러나 레이스 컨디션 같은 건 Claude의 분석이 피상적일 수 있다. 시작점으로는 쓸 만하지만, 맹신하면 안 된다.
- **POC의 한계가 있다.** 개인 API 계정이라 에러가 한꺼번에 폭주하면 rate limit에 걸릴 수 있다. 팀 차원 도입 시 정식 API 계정으로 전환이 필요하다.

---

## 마무리

AI 코드 리뷰에 이어 에러 모니터링까지 자동화해봤다. 둘 다 같은 패턴이다. 반복적인 수동 작업을 찾고, AI로 자동화하고, 개인 API 키로 POC를 돌려보고, 결과가 나오면 팀에 어필한다.

이 파이프라인의 가치는 AI가 사람을 대체하는 데 있지 않다. **에러 대응의 지루한 세레모니를 없애서, 사람이 진짜 중요한 일 — 원인 파악, 우선순위 판단, 수정 — 에 집중할 수 있게 하는 것**이다.

개인 API 키 하나, 월 $6으로 시작한 POC치고는 나쁘지 않은 결과였다. 안 됐으면 나만 시간 좀 쓴 거고, 됐으니까 팀에 공유할 수 있는 게 생겼다.
